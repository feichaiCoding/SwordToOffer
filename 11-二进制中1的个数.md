# 问题描述
输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。

```
public int NumberOf1(int n){}
```
# 问题分析
- 条件：需要把输入的整数转成二进制数（负数用补码表示）；
- 目标：二进制数中1的个数

# 求解思路1
求解二进制首先想到的是将其转成二进制然后逐个匹配来求1的个数
# 代码实现1 -- 菜鸡法

```
public static int NumberOf1(int n) {
	String result = Integer.toBinaryString(n);
	int count = 0;
	for(int i = 0; i < result.length(); i++){
		if(result.charAt(i) == '1'){
			count++;
		}
	}
    return count;
}
```
# 求解思路2
但是都API熟悉的可能会知道Integer有个自带的方法bitCount可以求1的位数

# 代码实现2 -- 小白法

```
public static int NumberOf1(int n) {
	return  Integer.bitCount(n);
	
}
```
# 求解思路3
虽然上面两种方法可以解决问题，但是还不够高效，对于二进制数，我们应该联想到位运算，如果我们能够利用位运算来每求一个1的个数就消掉一位，效率就可以大大提高。

对于一个二进制数求1的个数情况大致分为两种：
- 等于 0 ：1的个数为零
- 不等于0 ：1的个数至少有一个

对于不等于的情况，我们把它减去1，比如6的二进制110，那么对于最右边的1减去1后变成0，而且它后面的0变成1，即101，然后101 & 110 = 100，发现就可以消掉一位，然后将100继续减一后进行&操作直到最后全部置为0，所以消掉1的次数就是1 的个数，即n & (n - 1)

# 代码实现3 -- 推荐

```
public static int NumberOf1(int n){
		int count = 0;
		while(n != 0){
			n = n & (n - 1);
			count++;
		}
		return count;
	}
```
# 测试用例
{0}
{6}
{-6}
{69999}
{-69999}

# 相关知识点回顾
##### 基本的位运算(7种)
1. 与运算(&)：**两位全为1，结果才为1**，0&0=0；0&1=0；1&0=0；1&1=1

用法：清零，把想要清零的部分都与1进行与操作即可，例如：设X=10101110，取X的低四位，用X&0000 1111=0000 1110即可得到。

注意：&是按位与，用于运算，&&是短路与，用于判断
2.  或运算(|)：**两位全为0，结果为0，否则为1**。0|0=0； 0|1=1；1|0=1；1|1=1；

用法：置1，把想要置1的部分与1进行或运算，例如：0011 0011 | 0000 0101 =0011 0111

3. 异或运算(\^)：两位不同为1，相同则为0，0^0=0; 0^1=1; 1^0=1; 1^1=0;

用法：
- **与1相异或，使特定位翻转**，例如：X=1010 1110，使X低四位翻转，用X^0000 1111=1010 0001即可得到。
- **与0相异或，保留原值**，例如：X^0000 0000 =1010 1110
- **两个变量交换值**，一个数异或本身等于0 ；异或运算符合交换律：A=A\^B;B=A\^B;A=A\^B

4. 反码 (~):对一个二进制数按位取反，即将0变为1，1变0,例如，\~1=0 ；\~0=1

5. 左移(<<)**：无论正负，左边(也就是高位)丢弃，右边(也就是低位)补0，每移1位相当于乘2**

6. 右移(>>)：**在执行右移操作的时候，若参与的数为正，高位补0，若为负，高位补1**

7. 无符号右移(>>>)：**在执行右移操作的时候，无论正负，都补0。**

##### int转二进制的三种方法
###### 1、取余

```
public void binaryToDecimal(int n){
      int t = 0;  //用来记录位数
      int bin = 0; //用来记录最后的二进制数
      int r = 0;  //用来存储余数
      while(n != 0){
          r = n % 2;
          n = n / 2;
          bin += r * Math().pow(10,t);
          t++; 
     }
         System.out.println(bin);
 }
```
也可以通过字符串拼接方式
 
```
public void binaryToDecimal(int n){
     String str = "";
     while(n!=0){
         str = n%2+str;
         n = n/2;
     }
         System.out.println(str);
}
```

######  2、移位法
 说明：由于计算机中存储的都是数的补码，正数的原码、反码、补码都是相同的；而负数的原码、反码、补码是不一样的，**补码=原码取反+1（符号位不变）**。所以，负数是按照它的补码输出的

```
public void binaryToDecimal(int n){
      for(int i = 31;i >= 0; i--)//会循环32次。32就是一个int能存储的最大位数
          System.out.print(n >>> i & 1);
 }
```


###### 3、API中的方法

```
public void function1(int n){
     String result = Integer.toBinaryString(n);
     System.out.println(result);
 }
```
当一个数被转化成二进制时不会补齐其它位的0； 如果需要补齐前面的0，可以通过字符串拼接


