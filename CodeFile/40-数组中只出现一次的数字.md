# 问题描述
一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。

```
//num1,num2分别为长度为1的数组。传出参数
//将num1[0],num2[0]设置为返回结果
public class Solution {
    public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) {}
}
```

# 问题分析
- 条件：一个整型数组；出两个数字外，其他数字都出现两次
- 目标：将这个两个数分别赋值给num1[0],num2[0]

# 求解思路1 -- HashMap
利用hashMap的key值唯一性，将key赋值数组元素，value赋值出现次数，然后遍历数组找出HashMap中value为1的数字，时间复杂度O(n)，空间复杂度O(n)

# 求解思路2 -- 异或法
本题的目的在于筛选出这两个只出现一次的数字，换句话说，就是筛掉那些出现两次的数字，在**位运算中一个数异或本身等于0**，并且异或运算符合交换律，也就是说把这些数异或正好可以消掉这些出现两次的数字，而剩下的就是A\^B了
如[A, B, C, B, C, D],A\^B\^C\^B\^C\^D = A\^D，那么现在问题变成如何由最后的值来区分是那两个数得到的。也就是说如何靠这个值分开这两个数。

由于这两个数不同，那么他们异或的结果中至少有一个bit位上为1，而这个1就是异或值的最右边的上的1,所以我们可以记录这个位置index来区分这两个数。我们还是从头到尾依次异或数组中的每个数字，不过要分组，而分组条件就是每个数字的index位置上是否为1，那么这样就可以保证这两个出现一次的数被分到不同组，至于其它的数字由于会出现两次，他们在异或的过程中会相互抵消不会影响最终结果（因为最终异或结果上的1的位置就是他们异或得到的，其它的数在异或过程中这个位置上的1都被抵消掉了）

# 代码实现

```
public static void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) {
	num1[0] = 0;
	num2[0] = 0;
    if(array.length % 2 != 0){
		return;
	}
	
	if(array.length == 2 && array[0] != array[1]){
		num1[0] = array[0];
		num2[0] = array[1];
	}
	int tempSum = 0;//记录只出现一次的两个数的异或值（因为一个数异或自己会抵消）
	for(int i = 0; i < array.length; i++){
		tempSum ^= array[i];
	}
	
	int index = 0;//记录异或值tempSum最右边1出现的位置(一个数与1与运算，会将除1之外的其它位清零)
	while((tempSum & 1) == 0){
		tempSum = tempSum >> 1;
		index++;
	}
	
	//将数组分组（把两个出现一次的数分开）
	for(int i = 0; i < array.length; i++){
		boolean flag = ((array[i] >> index) & 1) == 0;//判断index位置上是否为1,不是1的话与1进行与运算得0
		if(flag){
			num1[0] ^= array[i];
		}else{
			num2[0] ^= array[i];
		}
	}
}
```

# 测试用例
- {1, 1, 2, 2, 3, 4}
- {1, 2, 3, 3, 4, 4}
- {6, 5, 7, 5, 7, 4}
- {1, 1, 2, 3, 4, 4}

# 相关知识点回顾
异或运算(\^)：两位不同为1，相同则为0，0^0=0; 0^1=1; 1^0=1; 1^1=0;

用法：
- **与1相异或，使特定位翻转**，例如：X=1010 1110，使X低四位翻转，用X^0000 1111=1010 0001即可得到。
- **与0相异或，保留原值**，例如：X\^0000 0000 =1010 1110
- 两个变量交换值，**一个数异或本身等于0** ；异或运算符合交换律：A=A\^B;B=A\^B;A=A\^B

与运算(&)：两位全为1，结果才为1，0&0=0；0&1=0；1&0=0；1&1=1

用法：**清零**，把想要清零的部分都与1进行与操作即可，例如：设X=10101110，取X的低四位，用X&0000 1111=0000 1110即可得到。

注意：&是按位与，用于运算，&&是短路与，用于判断