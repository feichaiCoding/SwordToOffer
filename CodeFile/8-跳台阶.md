# 问题描述
一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。

```
public int JumpFloor(int target) {}
```

# 问题分析
- 条件：一次可以跳1级或两级
- 目标：n级台阶跳法种类

# 求解思路1 -- 递归
假设只有10级台阶：

那么跳到10级的结果 = 从第8级跳两级到第10级台阶跳法 + 从第9级跳一级到第10级台阶跳法

那么跳到9级的结果 = 从第7级跳两级到第9级台阶跳法 + 从第8级跳一级到第9级台阶跳法

那么跳到8级的结果 = 从第6级跳两级到第8级台阶跳法 + 从第7级跳一级到第8级台阶跳法

以此类推，当只有1级或2级台阶时，可以直接得出结果F(1) = 1,F(2) = 2

可以得到
- F(n) = 1 , n = 1
- F(n) = 2 , n = 2
- 到达第n级跳法F(n) = 上一级跳法F(n - 1) + 上上级跳法F(n - 2) , n > 2

形式类似于斐波那契数列，可以使用递归方法求解

# 代码实现1

```
public static int JumpFloor(int target) {//递归
	if(target < 1){
		return 0;
	}
	
	if(target == 1 || target == 2){
		return target;
	}
	return JumpFloor(target - 1) + JumpFloor(target - 2);
}
```

# 求解思路2 -- 备忘录算法
递归方法计算过程存在大量重复运算，效率低，由于后面结果依赖于前面的结果，为避免重复计算可以考虑将前面结果存起来，可以创建一个hash表，将结果缓存起来，当遇到相同的参数时，直接取出

# 代码实现2

```
public static int JumpFloor(int target){//递归存在
	HashMap<Integer, Integer> result = new HashMap<>();
	if(target < 1){
		return 0;
	}
	
	if(target == 1 || target == 2){
		return target;
	}
	
	if(result.containsValue(target)){//每次计算F的时候首先寻找匹配元素，包含就直接取出结果
		return result.get(target);
	}else{//继续递归
		int tempValue = JumpFloor(target - 1) + JumpFloor(target - 2);
		result.put(target, tempValue);
		return tempValue;
	}
	
}
```

# 求解思路3 -- 动态规划
备忘录算法虽然解决了，重复计算问题，但是有额外开销，使用了集合HashMap，空间复杂度提高了。其实每次迭代的过程中，存在重复子问题，符合动态规划问题特征，所以可以利用动态规划求解。

# 代码实现3
```
public static int JumpFloor(int target){//递归
	if(target < 1){
		return 0;
	}
	
	if(target == 1 || target == 2){
		return target;
	}
	int resultOne = 1;
	int resultTwo = 2;
	int resultSum = 0;
	for(int i = 0; i < target - 2; i++){
		resultSum = resultOne + resultTwo;
		resultOne = resultTwo;
		resultTwo = resultSum;
	}
	return resultSum;
}
```
此时的空间复杂度为O(1)
# 测试用例
- {0}
- {1}
- {2}
- {3}
- {10}

# 相关知识点回顾

#### 动态规划算法说明
###### 思想：大事化小小事化了，把一个复杂的问题拆分成若干子问题
###### 问题特征
- 最优子结构：问题的最优解包含了其子问题的最优解
- 重叠子问题：在用递归算法自顶向下解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次
###### 动态规划的步骤
1. 问题建模
- 找到最优子结构，如上文的F(n - 1) ，F(n - 2)
- 确定问题边界，即结束条件，如上文的F(1) = 1 , F(2) = 2
- 分析最优子结构和边界关系，得到状态转移方程，如上文的F(n) = F(n - 1) + F(n - 2)

2. 问题求解:逐步优化
###### 分治和动态规划区别
- 共同点：都是讲原问题分而治之，把一个复杂的问题拆分成若干子问题，然后合并形成原问题的解
- 不同点：分治法分解的子问题都是相互独立；动态规划分解后的子问题都是互相联系，有重叠部分

#### 递归说明
###### 什么是递归
1)递归就是在过程或函数里面调用自身;

2)在使用递归时,必须有一个明确的递归结束条件,称为递归出口.

###### 递归分为两个阶段:

1)递推:把复杂的问题的求解拆分成比原问题简单一些的问题的求解;(入栈)

2)回归:当获得最简单的情况后,逐步返回,依次得到复杂的解.(出栈)

注意：由于递归需要系统堆栈，所以空间消耗要比非递归代码要大很多，而且，如果递归深度太大，可能系统资源会不够用。一般情况下能用迭代的就不要用递归

###### 递归和迭代（循环）的区别
- **递归就是自己调自己**，存在一个递和归的过程，递相当于入栈，归就相当于出栈逐步返回结果，而**迭代是反复执行一段代码，在原值基础上推算新值**。
- 递归代码简洁易懂，但需要堆栈，通常效率低（有时候还是挺快的）；
迭代代码复杂，但是没有额外的开销，执行效率高