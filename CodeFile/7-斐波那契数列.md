# 问题描述
大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。
n<=39

```
/**
@param n:整数(n <= 39)
@return int:斐波那契数列的第n项
*/
public int Fibonacci(int n) {}
```
注：斐波那契数列又称“兔子数列”，它的定义如下：
- n = 0, f(n) = 0;
- n = 1, f(n) = 1;
- n > 1, f(n) = f(n - 1) + f(n - 2);

# 问题分析
- 条件：斐波那契数列
- 目标：输出斐波那契数列的第n项(n <= 39)

# 求解思路
1. 递归：f(n) = f(n - 1) + f(n - 2)，缺点存在大量重复计算(画个树图就知道了)
2. 非递归：递归的效率低，使用循环方式。用临时变量将上一步(即f(n - 1))和上上步(即f(n - 2))的值存起来，我们只需要累加即可(所以这里要用到循环)，这样可以避免重复计算

###### 具体过程：
-  f(0) = 0
-  f(1) = 1
-  f(2) = f(1) + f(0)
-  f(3) = f(2) + f(1)
-  f(4) = f(3) + f(2)
-  f(5) = f(4) + f(3)
-  f(6) = f(5) + f(4)

观察可知，从第二次开始当前项的结果 = 上一次的结果 + 上上次的结果
- 当n == 0 || n == 1，直接返回n
- 当n > 1时，记录上上一次结果位置preTwo，记录上一次结果未知preOne
- 计算当前结果result = preOne + preTwo
- 更新上一次结果和上上次结果，用于下一次循环计算
- 循环前三个步骤，知道算出全部斐波那契

3. 非递归：通过观察斐波那契数列可知，f(n)都是由m个f(0)和k个f(1)组成

f(n) | m个f(0)| k个f(1)
---|---|---
f(0) = 0 | m = 1|k = 0
f(1) = 1 | m = 0| k = 1
f(2) = f(1) + f(0)      | m = 1| k = 1
f(3) = f(0) + 2f(1)     | m = 1| k = 2
f(4) = 2f(0) + 3f(1)    | m = 2| k = 3
f(5) = 3f(0) + 5f(1)    | m = 3| k = 5
f(6) = 5f(0) + 8f(1)    | m = 5| k = 8
 观察发现当前的m等于上一个的k，而当前的k等于上一个的m +
  k，所以f(n) = m\*f(0) + k\*f(1)
，并且f(0) = 0，f(1) = 1,所以最终只要求k的值即可
# 代码实现1 -- 递归

```
public static int Fibonacci1(int n) {//递归：f(n) = f(n - 1) + f(n - 2)，缺点存在大量重复计算
	
		if(n < 0 || n > 39){
			return -1;
		}
		if(n == 0){
			return 0;
		}
		if(n == 1){
			return 1;
		}
		
		return Fibonacci1(n - 1) + Fibonacci1(n - 2);

    }
```
# 代码实现2 -- 非递归1(通过存储上一次的结果实现)

```
public static int Fibonacci2(int n){//非递归：用临时变量将上一步的计算和存起来，这样可以避免重复	
	if(n < 0 || n > 39){
		return -1;
	}
	if(n == 0 || n == 1){
		return n;
	}
	int result = 0;
	int preOne = 0;
	int preTwo = 1;
	for(int i = 2; i <= n; i++){
		result = preOne + preTwo;//保存本次结果
		preOne = preTwo;//两个指针下移，那么preOne到了preTwo位置，而preTwo则到了result位置
		preTwo = result;
	}
	return result;
}

```
# 代码实现3 -- 非递归2(通过计算f(0)和f(1)的个数实现)

```
public static int Fibonacci2(int n) {	
		if(n < 0 || n > 39){
			return -1;
		}
		
		int mSum = 1;//m个f(0)
		int kSum = 0;//k个f(1)
		int temp = 0;//用于保存上一次的m + k
		while(n > 0){
		    temp = mSum + kSum;
		    mSum = kSum;//当前的m等于上一个的k
		    kSum = temp;//当前的k等于上一个的m + k
			n--;
		}
		
		return kSum;//f(0) = 0，f(1) = 1，所以最终只要求f(1)的个数k即可
    }
```


# 测试用例
- -1
- 0
- 1
- 2
- 38
- 39
- 40

# 相关知识点回顾
###### 什么是递归

1)递归就是在过程或函数里面调用自身;

2)在使用递归时,必须有一个明确的递归结束条件,称为递归出口.

递归分为两个阶段:

1)递推:把复杂的问题的求解推到比原问题简单一些的问题的求解;(入栈)

2)回归:当获得最简单的情况后,逐步返回,依次得到复杂的解.(出栈)

注意：由于递归需要系统堆栈，所以空间消耗要比非递归代码要大很多，而且，如果递归深度太大，可能系统资源会不够用。一般情况下能用迭代的就不要用递归

###### 递归和迭代（循环）的区别
- 递归就是自己调自己，存在一个递和归的过程，递相当于入栈，归就相当于出栈逐步返回结果，而迭代是反复执行一段代码，在原值基础上推算新值。
- 递归代码简洁易懂，但需要堆栈，通常效率低（有时候还是挺快的）；
迭代代码复杂，但是没有额外的开销，执行效率高