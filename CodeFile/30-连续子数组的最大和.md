# 问题描述
HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)

```
public int FindGreatestSumOfSubArray(int[] array){}
```
# 问题分析
- 条件：数组长度至少是1；有正有负
- 目标：最大连续子序列的和


# 求解思路1 -- 暴力破解法
找出所有子数组求和，然后比较大小找到最大子序列之和
# 代码实现1 -- 暴力破解法

```
public static int FindGreatestSumOfSubArray(int[] array){//暴力破解法
	int len = array.length;
	if(len == 1){
		return array[0];
	}
	int maxResult = Integer.MIN_VALUE;
	int tempMax = Integer.MIN_VALUE;
	for(int i = 0; i < len; i++){
		for(int j = i; j < len; j++){
			tempMax = Integer.MIN_VALUE;
			for(int k = i; k < j; k++){
				tempMax += array[k];
			}
			
			if(tempMax > maxResult){
				maxResult = tempMax;
			}
		}
	}
	return maxResult;
}
```
# 求解思路2 -- 动态规划法
上面的暴力破解法的时间复杂度为O(N^3)，现率太低，在计算过程中有很多重复计算。

涉及子问题可以考虑分治法和动态规划法
- 假如有一个数：n1，那么他的最大子序列为n1
- 假如有两个数：n1, n2，那么他的最大子序列之和就可能为[n1的最大子序列之和]，n2，n1 + n2
- 假如有三个数：n1,n2,n3,那么他的最大子序列之和就可能为[n1和n2的最大子序列之和]，n3，n1+n2+n3

以此类推，问题就变成了比较三个数的大小：
- 前n-1个数的最大子序列之和（这个就是上一步求得的最大子数组之和,即前n-2个元素中的最大子数组之和）
- 第n个数的数
- 前n个数之和

只要得到他们的最大值那么这个数就是整个数组的最大子序列之和。

在这个过程中子问题之间相互联系，所以用动态规划算法：
- 最优子结构:[n-1的最大子序列之和],arr[n],[n的子序列之和]
- 边界:arr[0]
- 状态转移方程：n个元素的最大子序列之和max = {max[n-1的最大子序列之和], arr[n], [n个数之和]}

# 代码实现2 -- 动态规划法


```
public static int FindGreatestSumOfSubArray(int[] array){//比较arr[n]、前n-1个数中的最大和tempMax以及前n项和tempSum这三个数
		int len = array.length;
		int tempMax = array[0];	
		int tempSum = array[0];	 
		for(int i = 1; i < len; i++){
			
			tempSum = getMaxValue(array[i], tempSum + array[i]);//注意这一步，它是指在第i位置的值与n-1个数值之和相比较，如果是n-1数值之和大，那么继续累加，如果是第i位置数大的话，那么前面n-1个数都没有用了直接在第i个数字上面累积
			tempMax = getMaxValue(tempMax, tempSum);
			
		}
		return tempMax;
	
}
public static int getMaxValue(int a, int b){
	return a>b?a:b;
}
```

# 测试用例
- {1}
- {-1}
- {2, -1}
- {-2, -1}
- {6,-3,-2,7,-15,1,2,2}
- {6,-3,-2,17,-15,1,2,2}


# 相关知识点回顾
##### 分治与动态规划区别
- 共同点：二者都要求原问题具有最优子结构性质,都是将原问题分而治之,分解成若干个规模较小(小到很容易解决的程序)的子问题.然后将子问题的解合并,形成原问题的解.
- 不同点：
分治法将分解后的子问题看成**相互独立**的，通过用递归来做。动态规划将分解后的子问题理解为**相互间有联系**,有重叠部分，需要记忆，通常用迭代来做。

##### 动态规划的步骤
- 1 问题建模
    - 1）根据问题，找到**【最优子结构】**。
把原问题从大化小的第一步，找到比当前问题要小一号的最好的结果，而一般情况下当前问题可以由最优子结构进行表示。
    - 2）确定问题的**【边界】**，也就是结束条件。
根据上述的最优子结构，一步一步从大化小，最终可以得到最小的，可以一眼看出答案的最优子结构，也就是边界。
    - 3）通过上述两步，通过分析最优子结构与最终问题之间的关系，我们可以得到**【状态转移方程】**。
- 2 问题求解